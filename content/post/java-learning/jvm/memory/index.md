+++
date = '2026-01-21T19:19:57+08:00'
draft = true
title = 'JVM 学习笔记'
description = 'JVM 内存区域'
categories = ['Java 学习']
tags = ['JVM', 'Java']

+++

## Hotspot 虚拟机创建对象

![v-8](http://cdn.cscat.cn/markdown/v-8.svg)

**step 1 类加载检查**

当虚拟机遇到一条 new 指令时，会先去检查这个指令的参数是否能在常量池中定位到这个符号引用，并且检查这个符号引用代表的类是否已经被加载过，解析和初始化过，如果没有，执行响应的操作。

**step 2 分配内存**

类加载检查通过后，虚拟机为新生对象分配内存，分配的方式有指针碰撞和空闲列表俩种方式，取决于使用的垃圾收集器，java堆是否规整。

指针碰撞的话适用于堆内存比较工整，使用该分配方式的垃圾回收器有 Serial, Parnew，原理是分配过的内存整合到一边，未分配的另一边，只保存一个中间分界的指针，分配内存时将指针往未分配内存一侧移动。

空闲列表相反，使用该分配方式的垃圾回收器有 CMS，原理是通过管理一个列表，列表中记录哪些内存是可用的，分配时找一块空间足够分配新对象空间。

虚拟机采用俩种方式来保证线程安全，**cas+失败重试，TLAB**，首先在tlab中分配内存，空间不足时使用cas

**step 3 初始化零值**

内存分配完成后，将分配到的内存空间都初始化为零值，不包括对象头，保证实例字段在 java 代码中可以不赋储初值就可以使用。

**step 4 设置对象头**

对象头中的信息包括了这个对象属于哪个类，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息，以及并发控制中要使用的偏向锁

**step 5 执行init方法**

执行程序员在代码中编写的 init 方法

## 对象的内存布局

对象的内存布局可以分为三个部分，**对象头**、**实例数据**和**对齐填充**

对象头包括俩部分信息 **标记字段** 哈希码，GC 分代年龄，锁装填标制，线程持有的锁，偏向线程id，偏向时间戳， **类型指针** 指向他的类元数据指针 

## 内存的访问定位

分为俩种，一种是句柄定位，一种是直接指针，句柄定位，指针指向的是一个句柄池中的一个对象的句柄，句柄中包含了对象实例数据的指针和对象类型数据的指针，直接指针字面意思，直接指向对象实例数据的指针

直接指针速度快，句柄访问，维护的句柄地址不会改变，指挥改变句柄中的指针的地址
